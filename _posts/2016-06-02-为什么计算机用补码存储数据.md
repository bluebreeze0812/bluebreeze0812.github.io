---
layout:     post
title:      为什么计算机用补码存储数据
date:       2016-06-02 20:27:00 +0800
author:     Leo
categories: Learn
tags:       CS
---
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在计算机内部，所有信息都是用二进制数串的形式表示的。整数通常都有正负之分，计算机中的整数分为无符号的和带符号的。无符号的整数用来表示0和正整数，带符号的证书可以表示所有的整数。由于计算机中符号和数字一样，都必须用二进制数串来表示，因此，正负号也必须用0、1来表示。通常我们用最高的有效位来表示数的符号（当用8位来表示一个整数时，第8位即为最高有效位，当用16位来表示一个整数时，第16位即为最高有效位。）0表示正号、1表示负号，这种正负号数字化的机内表示形式就称为“机器数”，而相应的机器外部用正负号表示的数称为“真值”。将一个真值表示成二进制字串的机器数的过程就称为编码。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无符号数没有原码、反码和补码一说。只有带符号数才存在不同的编码方式。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;带符号整数有原码、反码、补码等几种编码方式。原码即直接将真值转换为其相应的二进制形式，而反码和补码是对原码进行某种转换编码方式。正整数的原码、反码和补码都一样，负数的反码是对原码的除符号位外的其他位进行取反后的结果（取反即如果该位为0则变为1，而该位为1则变为0的操作）。而补码是先求原码的反码，然后在反码的末尾位加1 后得到的结果，即补码是反码+1。IBM-PC中带符号整数都采用补码形式表示。（注意，只是带符号的整数采用补码存储表示的，浮点数另有其存储方式。）

采用补码的原因或好处如下,采用补码运算具有如下两个特征：

1. 因为使用补码可以将符号位和其他位统一处理，同时，减法也可以按加法来处理，即如果是补码表示的数，不管是加减法都直接用加法运算即可实现。
2. 两个用补码表示的数相加时，如果最高位（符号位）有进位，则进位被舍弃。
这样的运算有两个好处：
  1. 使符号位能与有效值部分一起参加运算，从而简化运算规则。从而可以简化运算器的结构，提高运算速度；（减法运算可以用加法运算表示出来。）
  2. 加法运算比减法运算更易于实现。使减法运算转换为加法运算，进一步简化计算机中运算器的线路设计。


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面深入分析上面所陈述的采用补码的原因（目的）。
用带符号位的原码进行乘除运算时结果正确,而在加减运算的时候就出现了问题，如下： 

假设字长为8bits

>( 1 ) 10- ( 1 )10 = ( 1 )10 + ( -1 )10 = ( 0 )10<br>
>(00000001)原 + (10000001)原 = (10000010)原 = ( -2 )

显然不正确。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为在两个整数的加法运算中是没有问题的，于是就发现问题出现在带符号位的负数身上，对除符号位外的其余各位逐位取反就产生了反码。反码的取值空间和原码相同且一一对应。

下面是反码的减法运算：

>( 1 )10 - ( 1 ) 10= ( 1 ) 10+ ( -1 ) 10= ( 0 )10<br>
>(00000001) 反+ (11111110)反 = (11111111)反 = ( -0 ) 
 
 有问题。
 
>( 1 )10 - ( 2)10 = ( 1 )10 + ( -2 )10 = ( -1 )10<br>
>(00000001) 反+ (11111101)反 = (11111110)反 = ( -1 ) 

正确

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题出现在(+0)和(-0)上，在人们的计算概念中零是没有正负之分的。于是就引入了补码概念。负数的补码就是对反码加一，而正数不变，正数的原码反码补码是一样的。在补码中用(-128)代替了(-0)，所以补码的表示范围为(-128~0~127)共256个。
注意:(-128)没有相对应的原码和反码， (-128) = (10000000) 补码的加减运算如下：

>( 1 ) 10- ( 1 ) 10= ( 1 )10 + ( -1 )10 = ( 0 )10<br>
>(00000001)补 + (11111111)补 = (00000000)补 = ( 0 ) 

正确

>( 1 ) 10- ( 2) 10= ( 1 )10 + ( -2 )10 = ( -1 )10<br>
>(00000001) 补+ (11111110) 补= (11111111)补 = ( -1 )

正确

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采用补码表示还有另外一个原因，那就是为了防止0的机器数有两个编码。原码和反码表示的0有两种形式+0和-0，而我们知道，+0和-0是相同的。这样，8位的原码和反码表示的整数的范围就是-127~+127（11111111~01111111），而采用补码表示的时候，00000000是+0，即0；10000000不再是-0，而是-128，这样，补码表示的数的范围就是-128~+127了，不但增加了一个数得表示范围，而且还保证了0编码的唯一性。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整数和0的原码、反码和补码都相同，下面介绍手工快速求负数补码的方法。这个方法在教材的第8页已经提到了，这里再写出来以便能引起大家的注意。其方法如下：

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先写出该负数的相反数（正数），再将该正数的二进制形式写出来，然后对这个二进制位串按位取反，即若是1则改为0，若是0则改为1，最后在末位加1。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来的问题是，如何能将减法运算转换成加法运算呢？

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经知道，原码表示简单直观，与真值转换容易。但如果用原码表示，其符号位不能参加运算。在计算机中用原码实现算术运算时，要取绝对值参加运算，符号位单独处理，这对乘除运算是很容易实现的，但对加减运算是非常不方便的，如两个异号数相加，实际是要做减法，而两个异号数相减，实际是要做加法。在做减法时，还要判断操作数绝对值的大小，这些都会使运算器的设计变得很复杂。而补码这种编码方式实际上正是针对上述问题的。通过用补码进行表示，就可以把减法运算化为加法运算。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在日常生活中，有许多化减为加的例子。例如，时钟是逢12进位，12点也可看作0点。当将时针从10点调整到5点时有以下两种方法：
1. 一种方法是时针逆时针方向拨5格，相当于做减法：
    10－5＝5
2. 另一种方法是时针顺时针方向拨7格，相当于做加法：
    10＋7＝12＋5＝5    (MOD 12)
    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是由于时钟以12 为模，在这个前提下，当和超过12时，可将12舍去。于是，减5相当于加7。同理，减4可表示成加8，减3可表示成加9.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在数学中，用“同余”概念描述上述关系，即两整数A、B用同一个正整数M (M称为模)去除而余数相等，则称A、B对M同余，记作：

>A＝B     (MOD  M)
    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具有同余关系的两个数为互补关系，其中一个称为另一个的补码。当M＝12时，－5和＋7，－4和＋8，－3和＋9就是同余的，它们互为补码。
从同余的概念和上述时钟的例子，不难得出结论：对于某一确定的模，用某数减去小于模的另一个数，总可以用加上“模减去该数绝对值的差”来代替。因此，在有模运算中，减法就可以化作加法来做。

可以看出，补码的加法运算所依据的基本关系为：

>[x]补+ [y]补= [x+y]补

补码减法所依据的基本关系式：

>[x-y]补 =[x+(-y)]补= [x]补+ [-y]补

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至于加法运算为什么比减法运算易于实现以及CPU如何实现各种算术运算等问题，则需要通过对数字电路的学习来理解CPU的运算器的硬件实现问题的相关内容了。

总的来说，使用补码来存储数据有三个好处：
1. 将减法运算化为加法运算，使计算机线路设计更为简易。
2. 符号位可以参与运算，如有进位则溢出舍弃。
3. 扩充了负数可表示的范围（10000000）表示-128，同时保证了0的唯一性。




